<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>datalevin.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Datalevin</span> <span class="project-version">0.2.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datalevin</span></div></div></li><li class="depth-2 branch current"><a href="datalevin.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="datalevin.lmdb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lmdb</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="datalevin.core.html#var-close"><div class="inner"><span>close</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn-from-datoms"><div class="inner"><span>conn-from-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn-from-db"><div class="inner"><span>conn-from-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn.3F"><div class="inner"><span>conn?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-create-conn"><div class="inner"><span>create-conn</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-data-readers"><div class="inner"><span>data-readers</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom"><div class="inner"><span>datom</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom.3F"><div class="inner"><span>datom?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datoms"><div class="inner"><span>datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db"><div class="inner"><span>db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db-with"><div class="inner"><span>db-with</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db.3F"><div class="inner"><span>db?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-empty-db"><div class="inner"><span>empty-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entid"><div class="inner"><span>entid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entity"><div class="inner"><span>entity</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entity-db"><div class="inner"><span>entity-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-index-range"><div class="inner"><span>index-range</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-init-db"><div class="inner"><span>init-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-listen.21"><div class="inner"><span>listen!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-pull"><div class="inner"><span>pull</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-pull-many"><div class="inner"><span>pull-many</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-q"><div class="inner"><span>q</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-reset-conn.21"><div class="inner"><span>reset-conn!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-resolve-tempid"><div class="inner"><span>resolve-tempid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-rseek-datoms"><div class="inner"><span>rseek-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-seek-datoms"><div class="inner"><span>seek-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-squuid"><div class="inner"><span>squuid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-squuid-time-millis"><div class="inner"><span>squuid-time-millis</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-tempid"><div class="inner"><span>tempid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-touch"><div class="inner"><span>touch</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact"><div class="inner"><span>transact</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact.21"><div class="inner"><span>transact!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact-async"><div class="inner"><span>transact-async</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-unlisten.21"><div class="inner"><span>unlisten!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-with"><div class="inner"><span>with</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">datalevin.core</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close conn)</code></div><div class="doc"><pre class="plaintext">Close the connection
</pre></div></div><div class="public anchor" id="var-conn-from-datoms"><h3>conn-from-datoms</h3><div class="usage"><code>(conn-from-datoms datoms)</code><code>(conn-from-datoms datoms schema)</code><code>(conn-from-datoms datoms schema dir)</code></div><div class="doc"><pre class="plaintext">Creates an empty DB and a mutable reference to it. See [[create-conn]].
</pre></div></div><div class="public anchor" id="var-conn-from-db"><h3>conn-from-db</h3><div class="usage"><code>(conn-from-db db)</code></div><div class="doc"><pre class="plaintext">Creates a mutable reference to a given database. See [[create-conn]].
</pre></div></div><div class="public anchor" id="var-conn.3F"><h3>conn?</h3><div class="usage"><code>(conn? conn)</code></div><div class="doc"><pre class="plaintext">Returns `true` if this is a connection to a DataScript db, `false` otherwise.
</pre></div></div><div class="public anchor" id="var-create-conn"><h3>create-conn</h3><div class="usage"><code>(create-conn)</code><code>(create-conn schema)</code><code>(create-conn schema dir)</code></div><div class="doc"><pre class="plaintext">Creates a mutable reference (a “connection”) to an empty database.

Connections are lightweight in-memory structures (~atoms) DataScript APIs ([[transact!]], [[db]]).

To access underlying DB, deref: `@conn`.</pre></div></div><div class="public anchor" id="var-data-readers"><h3>data-readers</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Data readers for EDN readers. If `data_readers.clj` do not work, you can always do

```
(clojure.edn/read-string {:readers data-readers} "...")
```</pre></div></div><div class="public anchor" id="var-datom"><h3>datom</h3><div class="usage"><code>(datom e a v)</code><code>(datom e a v tx)</code><code>(datom e a v tx added)</code></div><div class="doc"><pre class="plaintext">Low-level fn to create raw datoms.

Optionally with transaction id (number) and `added` flag (`true` for addition, `false` for retraction).

See also [[init-db]].</pre></div></div><div class="public anchor" id="var-datom.3F"><h3>datom?</h3><div class="usage"><code>(datom? x)</code></div><div class="doc"><pre class="plaintext">Returns `true` if the given value is a datom, `false` otherwise.
</pre></div></div><div class="public anchor" id="var-datoms"><h3>datoms</h3><div class="usage"><code>(datoms db index)</code><code>(datoms db index c1)</code><code>(datoms db index c1 c2)</code><code>(datoms db index c1 c2 c3)</code><code>(datoms db index c1 c2 c3 c4)</code></div><div class="doc"><pre class="plaintext">Index lookup. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.

Datoms are sorted in index sort order. Possible `index` values are: `:eavt`, `:aevt`, `:avet`, `:vaet`, or without the `t` at the end, e.g. `:eav`.

Usage:

    ; find all datoms for entity id == 1 (any attrs and values)
    ; sort by attribute, then value
    (datoms db :eavt 1)
    ; =&gt; (#datalevin/Datom [1 :friends 2]
    ;     #datalevin/Datom [1 :likes "fries"]
    ;     #datalevin/Datom [1 :likes "pizza"]
    ;     #datalevin/Datom [1 :name "Ivan"])

    ; find all datoms for entity id == 1 and attribute == :likes (any values)
    ; sorted by value
    (datoms db :eavt 1 :likes)
    ; =&gt; (#datalevin/Datom [1 :likes "fries"]
    ;     #datalevin/Datom [1 :likes "pizza"])

    ; find all datoms for entity id == 1, attribute == :likes and value == "pizza"
    (datoms db :eavt 1 :likes "pizza")
    ; =&gt; (#datalevin/Datom [1 :likes "pizza"])

    ; find all datoms for attribute == :likes (any entity ids and values)
    ; sorted by entity id, then value
    (datoms db :aevt :likes)
    ; =&gt; (#datalevin/Datom [1 :likes "fries"]
    ;     #datalevin/Datom [1 :likes "pizza"]
    ;     #datalevin/Datom [2 :likes "candy"]
    ;     #datalevin/Datom [2 :likes "pie"]
    ;     #datalevin/Datom [2 :likes "pizza"])

    ; find all datoms that have attribute == `:likes` and value == `"pizza"` (any entity id)
    (datoms db :avet :likes "pizza")
    ; =&gt; (#datalevin/Datom [1 :likes "pizza"]
    ;     #datalevin/Datom [2 :likes "pizza"])

    ; find all datoms sorted by entity id, then attribute, then value
    (datoms db :eavt) ; =&gt; (...)

Useful patterns:

    ; get all values of :db.cardinality/many attribute
    (-&gt;&gt; (datoms db :eavt eid attr) (map :v))

    ; lookup entity ids by attribute value
    (-&gt;&gt; (datoms db :avet attr value) (map :e))

    ; find all entities with a specific attribute
    (-&gt;&gt; (datoms db :aevt attr) (map :e))

    ; find “singleton” entity by its attr
    (-&gt;&gt; (datoms db :aevt attr) first :e)

    ; find N entities with lowest attr value (e.g. 10 earliest posts)
    (-&gt;&gt; (datoms db :avet attr) (take N))

    ; find N entities with highest attr value (e.g. 10 latest posts)
    (-&gt;&gt; (datoms db :avet attr) (reverse) (take N))

Gotchas:

- Index lookup is usually more efficient than doing a query with a single clause.
- Resulting iterator is calculated in constant time and small constant memory overhead.
- Iterator supports efficient `first`, `next`, `reverse`, `seq` and is itself a sequence.</pre></div></div><div class="public anchor" id="var-db"><h3>db</h3><div class="usage"><code>(db conn)</code></div><div class="doc"><pre class="plaintext">Returns the underlying database value from a connection.

Exists for Datomic API compatibility. Prefer using `@conn` directly if possible.</pre></div></div><div class="public anchor" id="var-db-with"><h3>db-with</h3><div class="usage"><code>(db-with db tx-data)</code></div><div class="doc"><pre class="plaintext">Applies transaction. Return the db.
</pre></div></div><div class="public anchor" id="var-db.3F"><h3>db?</h3><div class="usage"><code>(db? x)</code></div><div class="doc"><pre class="plaintext">Returns `true` if the given value is an database, `false` otherwise.
</pre></div></div><div class="public anchor" id="var-empty-db"><h3>empty-db</h3><div class="usage"><code>(empty-db)</code><code>(empty-db schema)</code><code>(empty-db schema dir)</code></div><div class="doc"><pre class="plaintext">Creates an empty database with an optional schema.

Usage:

```
(empty-db) ; =&gt; #datalevin/DB {:schema {}, :datoms []}

(empty-db {:likes {:db/cardinality :db.cardinality/many}})
; =&gt; #datalevin/DB {:schema {:likes {:db/cardinality :db.cardinality/many}}
;                    :datoms []}
```</pre></div></div><div class="public anchor" id="var-entid"><h3>entid</h3><div class="usage"><code>(entid db eid)</code></div><div class="doc"><pre class="plaintext">Given lookup ref `[unique-attr value]`, returns numberic entity id.

If entity does not exist, returns `nil`.

For numeric `eid` returns `eid` itself (does not check for entity existence in that case).</pre></div></div><div class="public anchor" id="var-entity"><h3>entity</h3><div class="usage"><code>(entity db eid)</code></div><div class="doc"><pre class="plaintext">Retrieves an entity by its id from database. Entities are lazy map-like structures to navigate DataScript database content.

For `eid` pass entity id or lookup attr:

    (entity db 1)
    (entity db [:unique-attr :value])

If entity does not exist, `nil` is returned:

    (entity db 100500) ; =&gt; nil

Creating an entity by id is very cheap, almost no-op, as attr access is on-demand:

    (entity db 1) ; =&gt; {:db/id 1}

Entity attributes can be lazily accessed through key lookups:

    (:attr (entity db 1)) ; =&gt; :value
    (get (entity db 1) :attr) ; =&gt; :value

Cardinality many attributes are returned sequences:

    (:attrs (entity db 1)) ; =&gt; [:v1 :v2 :v3]

Reference attributes are returned as another entities:

    (:ref (entity db 1)) ; =&gt; {:db/id 2}
    (:ns/ref (entity db 1)) ; =&gt; {:db/id 2}

References can be walked backwards by prepending `_` to name part of an attribute:

    (:_ref (entity db 2)) ; =&gt; [{:db/id 1}]
    (:ns/_ref (entity db 2)) ; =&gt; [{:db/id 1}]

Reverse reference lookup returns sequence of entities unless attribute is marked as `:db/component`:

    (:_component-ref (entity db 2)) ; =&gt; {:db/id 1}

Entity gotchas:

- Entities print as map, but are not exactly maps (they have compatible get interface though).
- Entities are effectively immutable “views” into a particular version of a database.
- Entities retain reference to the whole database.
- You can’t change database through entities, only read.
- Creating an entity by id is very cheap, almost no-op (attributes are looked up on demand).
- Comparing entities just compares their ids. Be careful when comparing entities taken from differenct dbs or from different versions of the same db.
- Accessed entity attributes are cached on entity itself (except backward references).
- When printing, only cached attributes (the ones you have accessed before) are printed. See [[touch]].</pre></div></div><div class="public anchor" id="var-entity-db"><h3>entity-db</h3><div class="usage"><code>(entity-db entity)</code></div><div class="doc"><pre class="plaintext">Returns a db that entity was created from.
</pre></div></div><div class="public anchor" id="var-index-range"><h3>index-range</h3><div class="usage"><code>(index-range db attr start end)</code></div><div class="doc"><pre class="plaintext">Returns part of `:avet` index between `[_ attr start]` and `[_ attr end]` in AVET sort order.

Same properties as [[datoms]].

Usage:

    (index-range db :likes "a" "zzzzzzzzz")
    ; =&gt; (#datalevin/Datom [2 :likes "candy"]
    ;     #datalevin/Datom [1 :likes "fries"]
    ;     #datalevin/Datom [2 :likes "pie"]
    ;     #datalevin/Datom [1 :likes "pizza"]
    ;     #datalevin/Datom [2 :likes "pizza"])

    (index-range db :likes "egg" "pineapple")
    ; =&gt; (#datalevin/Datom [1 :likes "fries"]
    ;     #datalevin/Datom [2 :likes "pie"])

Useful patterns:

    ; find all entities with age in a specific range (inclusive)
    (-&gt;&gt; (index-range db :age 18 60) (map :e))</pre></div></div><div class="public anchor" id="var-init-db"><h3>init-db</h3><div class="usage"><code>(init-db datoms)</code><code>(init-db datoms schema)</code></div><div class="doc"><pre class="plaintext">Low-level fn for creating database quickly from a trusted sequence of datoms.

Does no validation on inputs, so `datoms` must be well-formed and match schema.

See also [[datom]].</pre></div></div><div class="public anchor" id="var-listen.21"><h3>listen!</h3><div class="usage"><code>(listen! conn callback)</code><code>(listen! conn key callback)</code></div><div class="doc"><pre class="plaintext">Listen for changes on the given connection. Whenever a transaction is applied to the database via [[transact!]], the callback is called
with the transaction report. `key` is any opaque unique value.

Idempotent. Calling [[listen!]] with the same key twice will override old callback with the new value.

Returns the key under which this listener is registered. See also [[unlisten!]].</pre></div></div><div class="public anchor" id="var-pull"><h3>pull</h3><div class="usage"><code>(pull db selector eid)</code></div><div class="doc"><pre class="plaintext">Fetches data from database using recursive declarative description. See [docs.datomic.com/on-prem/pull.html](<a href="https://docs.datomic.com/on-prem/pull.html)">https://docs.datomic.com/on-prem/pull.html)</a>.

Unlike [[entity]], returns plain Clojure map (not lazy).

Usage:

    (pull db [:db/id, :name, :likes, {:friends [:db/id :name]}] 1)
    ; =&gt; {:db/id   1,
    ;     :name    "Ivan"
    ;     :likes   [:pizza]
    ;     :friends [{:db/id 2, :name "Oleg"}]}</pre></div></div><div class="public anchor" id="var-pull-many"><h3>pull-many</h3><div class="usage"><code>(pull-many db selector eids)</code></div><div class="doc"><pre class="plaintext">Same as [[pull]], but accepts sequence of ids and returns sequence of maps.

Usage:

```
(pull-many db [:db/id :name] [1 2])
; =&gt; [{:db/id 1, :name "Ivan"}
;     {:db/id 2, :name "Oleg"}]
```</pre></div></div><div class="public anchor" id="var-q"><h3>q</h3><div class="usage"><code>(q query &amp; inputs)</code></div><div class="doc"><pre class="plaintext">Executes a datalog query. See [docs.datomic.com/on-prem/query.html](<a href="https://docs.datomic.com/on-prem/query.html)">https://docs.datomic.com/on-prem/query.html)</a>.

Usage:

```
(q '[:find ?value
     :where [_ :likes ?value]]
   db)
; =&gt; #{["fries"] ["candy"] ["pie"] ["pizza"]}
```</pre></div></div><div class="public anchor" id="var-reset-conn.21"><h3>reset-conn!</h3><div class="usage"><code>(reset-conn! conn db)</code><code>(reset-conn! conn db tx-meta)</code></div><div class="doc"><pre class="plaintext">Forces underlying `conn` value to become `db`. Will generate a tx-report that will remove everything from old value and insert everything from the new one.
</pre></div></div><div class="public anchor" id="var-resolve-tempid"><h3>resolve-tempid</h3><div class="usage"><code>(resolve-tempid _db tempids tempid)</code></div><div class="doc"><pre class="plaintext">Does a lookup in tempids map, returning an entity id that tempid was resolved to.

Exists for Datomic API compatibility. Prefer using map lookup directly if possible.</pre></div></div><div class="public anchor" id="var-rseek-datoms"><h3>rseek-datoms</h3><div class="usage"><code>(rseek-datoms db index)</code><code>(rseek-datoms db index c1)</code><code>(rseek-datoms db index c1 c2)</code><code>(rseek-datoms db index c1 c2 c3)</code><code>(rseek-datoms db index c1 c2 c3 c4)</code></div><div class="doc"><pre class="plaintext">Same as [[seek-datoms]], but goes backwards until the beginning of the index.
</pre></div></div><div class="public anchor" id="var-seek-datoms"><h3>seek-datoms</h3><div class="usage"><code>(seek-datoms db index)</code><code>(seek-datoms db index c1)</code><code>(seek-datoms db index c1 c2)</code><code>(seek-datoms db index c1 c2 c3)</code><code>(seek-datoms db index c1 c2 c3 c4)</code></div><div class="doc"><pre class="plaintext">Similar to [[datoms]], but will return datoms starting from specified components and including rest of the database until the end of the index.

If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.

Usage:

    (seek-datoms db :eavt 1)
    ; =&gt; (#datalevin/Datom [1 :friends 2]
    ;     #datalevin/Datom [1 :likes "fries"]
    ;     #datalevin/Datom [1 :likes "pizza"]
    ;     #datalevin/Datom [1 :name "Ivan"]
    ;     #datalevin/Datom [2 :likes "candy"]
    ;     #datalevin/Datom [2 :likes "pie"]
    ;     #datalevin/Datom [2 :likes "pizza"])

    (seek-datoms db :eavt 1 :name)
    ; =&gt; (#datalevin/Datom [1 :name "Ivan"]
    ;     #datalevin/Datom [2 :likes "candy"]
    ;     #datalevin/Datom [2 :likes "pie"]
    ;     #datalevin/Datom [2 :likes "pizza"])

    (seek-datoms db :eavt 2)
    ; =&gt; (#datalevin/Datom [2 :likes "candy"]
    ;     #datalevin/Datom [2 :likes "pie"]
    ;     #datalevin/Datom [2 :likes "pizza"])

    ; no datom [2 :likes "fish"], so starts with one immediately following such in index
    (seek-datoms db :eavt 2 :likes "fish")
    ; =&gt; (#datalevin/Datom [2 :likes "pie"]
    ;     #datalevin/Datom [2 :likes "pizza"])</pre></div></div><div class="public anchor" id="var-squuid"><h3>squuid</h3><div class="usage"><code>(squuid)</code><code>(squuid msec)</code></div><div class="doc"><pre class="plaintext">Generates a UUID that grow with time. Such UUIDs will always go to the end  of the index and that will minimize insertions in the middle.

Consist of 64 bits of current UNIX timestamp (in seconds) and 64 random bits (2^64 different unique values per second).</pre></div></div><div class="public anchor" id="var-squuid-time-millis"><h3>squuid-time-millis</h3><div class="usage"><code>(squuid-time-millis uuid)</code></div><div class="doc"><pre class="plaintext">Returns time that was used in [[squuid]] call, in milliseconds, rounded to the closest second.
</pre></div></div><div class="public anchor" id="var-tempid"><h3>tempid</h3><div class="usage"><code>(tempid part)</code><code>(tempid part x)</code></div><div class="doc"><pre class="plaintext">Allocates and returns an unique temporary id (a negative integer). Ignores `part`. Returns `x` if it is specified.

Exists for Datomic API compatibility. Prefer using negative integers directly if possible.</pre></div></div><div class="public anchor" id="var-touch"><h3>touch</h3><div class="usage"><code>(touch e)</code></div><div class="doc"><pre class="plaintext">Forces all entity attributes to be eagerly fetched and cached. Only usable for debug output.

Usage:

```
(entity db 1) ; =&gt; {:db/id 1}
(touch (entity db 1)) ; =&gt; {:db/id 1, :dislikes [:pie], :likes [:pizza]}
```</pre></div></div><div class="public anchor" id="var-transact"><h3>transact</h3><div class="usage"><code>(transact conn tx-data)</code><code>(transact conn tx-data tx-meta)</code></div><div class="doc"><pre class="plaintext">Same as [[transact!]], but returns an immediately realized future.

Exists for Datomic API compatibility. Prefer using [[transact!]] if possible.</pre></div></div><div class="public anchor" id="var-transact.21"><h3>transact!</h3><div class="usage"><code>(transact! conn tx-data)</code><code>(transact! conn tx-data tx-meta)</code></div><div class="doc"><pre class="plaintext">Applies transaction the underlying database value and atomically updates connection reference to point to the result of that transaction, new db value.

 Returns transaction report, a map:

     { :db-before ...       ; db value before transaction
       :db-after  ...       ; db value after transaction
       :tx-data   [...]     ; plain datoms that were added/retracted from db-before
       :tempids   {...}     ; map of tempid from tx-data =&gt; assigned entid in db-after
       :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`

Note! `conn` will be updated in-place and is not returned from [[transact!]].

Usage:

    ; add a single datom to an existing entity (1)
    (transact! conn [[:db/add 1 :name "Ivan"]])

    ; retract a single datom
    (transact! conn [[:db/retract 1 :name "Ivan"]])

    ; retract single entity attribute
    (transact! conn [[:db.fn/retractAttribute 1 :name]])

    ; ... or equivalently (since Datomic changed its API to support this):
    (transact! conn [[:db/retract 1 :name]])

    ; retract all entity attributes (effectively deletes entity)
    (transact! conn [[:db.fn/retractEntity 1]])

    ; create a new entity (`-1`, as any other negative value, is a tempid
    ; that will be replaced with DataScript to a next unused eid)
    (transact! conn [[:db/add -1 :name "Ivan"]])

    ; check assigned id (here `*1` is a result returned from previous `transact!` call)
    (def report *1)
    (:tempids report) ; =&gt; {-1 296}

    ; check actual datoms inserted
    (:tx-data report) ; =&gt; [#datalevin/Datom [296 :name "Ivan"]]

    ; tempid can also be a string
    (transact! conn [[:db/add "ivan" :name "Ivan"]])
    (:tempids *1) ; =&gt; {"ivan" 297}

    ; reference another entity (must exist)
    (transact! conn [[:db/add -1 :friend 296]])

    ; create an entity and set multiple attributes (in a single transaction
    ; equal tempids will be replaced with the same unused yet entid)
    (transact! conn [[:db/add -1 :name "Ivan"]
                     [:db/add -1 :likes "fries"]
                     [:db/add -1 :likes "pizza"]
                     [:db/add -1 :friend 296]])

    ; create an entity and set multiple attributes (alternative map form)
    (transact! conn [{:db/id  -1
                      :name   "Ivan"
                      :likes  ["fries" "pizza"]
                      :friend 296}])

    ; update an entity (alternative map form). Can’t retract attributes in
    ; map form. For cardinality many attrs, value (fish in this example)
    ; will be added to the list of existing values
    (transact! conn [{:db/id  296
                      :name   "Oleg"
                      :likes  ["fish"]}])

    ; ref attributes can be specified as nested map, that will create netsed entity as well
    (transact! conn [{:db/id  -1
                      :name   "Oleg"
                      :friend {:db/id -2
                               :name "Sergey"}])

    ; reverse attribute name can be used if you want created entity to become
    ; a value in another entity reference
    (transact! conn [{:db/id  -1
                      :name   "Oleg"
                      :_friend 296}])
    ; equivalent to
    (transact! conn [{:db/id  -1, :name   "Oleg"}
                     {:db/id 296, :friend -1}])
    ; equivalent to
    (transact! conn [[:db/add  -1 :name   "Oleg"]
                     {:db/add 296 :friend -1]])</pre></div></div><div class="public anchor" id="var-transact-async"><h3>transact-async</h3><div class="usage"><code>(transact-async conn tx-data)</code><code>(transact-async conn tx-data tx-meta)</code></div><div class="doc"><pre class="plaintext">Calls [[transact!]] on a future thread pool, returning immediately.
</pre></div></div><div class="public anchor" id="var-unlisten.21"><h3>unlisten!</h3><div class="usage"><code>(unlisten! conn key)</code></div><div class="doc"><pre class="plaintext">Removes registered listener from connection. See also [[listen!]].
</pre></div></div><div class="public anchor" id="var-with"><h3>with</h3><div class="usage"><code>(with db tx-data)</code><code>(with db tx-data tx-meta)</code></div><div class="doc"><pre class="plaintext">Same as [[transact!]]. Returns transaction report (see [[transact!]]).
</pre></div></div></div></body></html>