<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>datalevin.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Datalevin</span> <span class="project-version">0.2.9</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datalevin</span></div></div></li><li class="depth-2 branch"><a href="datalevin.bits.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bits</span></div></a></li><li class="depth-2 branch current"><a href="datalevin.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="datalevin.lmdb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lmdb</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="datalevin.core.html#var-close"><div class="inner"><span>close</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn-from-datoms"><div class="inner"><span>conn-from-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn-from-db"><div class="inner"><span>conn-from-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn.3F"><div class="inner"><span>conn?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-create-conn"><div class="inner"><span>create-conn</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-data-readers"><div class="inner"><span>data-readers</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom"><div class="inner"><span>datom</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom.3F"><div class="inner"><span>datom?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datoms"><div class="inner"><span>datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db"><div class="inner"><span>db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db-with"><div class="inner"><span>db-with</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db.3F"><div class="inner"><span>db?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-empty-db"><div class="inner"><span>empty-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entid"><div class="inner"><span>entid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entity"><div class="inner"><span>entity</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entity-db"><div class="inner"><span>entity-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-index-range"><div class="inner"><span>index-range</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-init-db"><div class="inner"><span>init-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-listen.21"><div class="inner"><span>listen!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-pull"><div class="inner"><span>pull</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-pull-many"><div class="inner"><span>pull-many</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-q"><div class="inner"><span>q</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-reset-conn.21"><div class="inner"><span>reset-conn!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-resolve-tempid"><div class="inner"><span>resolve-tempid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-rseek-datoms"><div class="inner"><span>rseek-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-seek-datoms"><div class="inner"><span>seek-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-squuid"><div class="inner"><span>squuid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-squuid-time-millis"><div class="inner"><span>squuid-time-millis</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-tempid"><div class="inner"><span>tempid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-touch"><div class="inner"><span>touch</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact"><div class="inner"><span>transact</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact.21"><div class="inner"><span>transact!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact-async"><div class="inner"><span>transact-async</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-unlisten.21"><div class="inner"><span>unlisten!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-with"><div class="inner"><span>with</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">datalevin.core</h1><div class="doc"><div class="markdown"><p>API for Datalog store</p></div></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close conn)</code></div><div class="doc"><div class="markdown"><p>Close the connection</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L594">view source</a></div></div><div class="public anchor" id="var-conn-from-datoms"><h3>conn-from-datoms</h3><div class="usage"><code>(conn-from-datoms datoms)</code><code>(conn-from-datoms datoms schema)</code><code>(conn-from-datoms datoms schema dir)</code></div><div class="doc"><div class="markdown"><p>Creates an empty DB and a mutable reference to it. See <a href="datalevin.core.html#var-create-conn">create-conn</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L380">view source</a></div></div><div class="public anchor" id="var-conn-from-db"><h3>conn-from-db</h3><div class="usage"><code>(conn-from-db db)</code></div><div class="doc"><div class="markdown"><p>Creates a mutable reference to a given database. See <a href="datalevin.core.html#var-create-conn">create-conn</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L374">view source</a></div></div><div class="public anchor" id="var-conn.3F"><h3>conn?</h3><div class="usage"><code>(conn? conn)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if this is a connection to a Datalevin db, <code>false</code> otherwise.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L366">view source</a></div></div><div class="public anchor" id="var-create-conn"><h3>create-conn</h3><div class="usage"><code>(create-conn)</code><code>(create-conn schema)</code><code>(create-conn schema dir)</code></div><div class="doc"><div class="markdown"><p>Creates a mutable reference (a “connection”) to an empty database.</p>
<p>Connections are lightweight in-memory structures (~atoms). See also <a href="datalevin.core.html#var-transact.21">transact!</a>, <a href="datalevin.core.html#var-db">db</a>.</p>
<p>To access underlying DB, deref: <code>@conn</code>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L387">view source</a></div></div><div class="public anchor" id="var-data-readers"><h3>data-readers</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Data readers for EDN readers. If <code>data_readers.clj</code> do not work, you can always do</p>
<pre><code>(clojure.edn/read-string {:readers data-readers} "...")
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L547">view source</a></div></div><div class="public anchor" id="var-datom"><h3>datom</h3><div class="usage"><code>(datom e a v)</code><code>(datom e a v tx)</code><code>(datom e a v tx added)</code></div><div class="doc"><div class="markdown"><p>Low-level fn to create raw datoms.</p>
<p>Optionally with transaction id (number) and <code>added</code> flag (<code>true</code> for addition, <code>false</code> for retraction).</p>
<p>See also <a href="datalevin.core.html#var-init-db">init-db</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L170">view source</a></div></div><div class="public anchor" id="var-datom.3F"><h3>datom?</h3><div class="usage"><code>(datom? x)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if the given value is a datom, <code>false</code> otherwise.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L179">view source</a></div></div><div class="public anchor" id="var-datoms"><h3>datoms</h3><div class="usage"><code>(datoms db index)</code><code>(datoms db index c1)</code><code>(datoms db index c1 c2)</code><code>(datoms db index c1 c2 c3)</code><code>(datoms db index c1 c2 c3 c4)</code></div><div class="doc"><div class="markdown"><p>Index lookup. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.</p>
<p>Datoms are sorted in index sort order. Possible <code>index</code> values are: <code>:eavt</code>, <code>:aevt</code>, <code>:avet</code>, <code>:vaet</code>, or without the <code>t</code> at the end, e.g. <code>:eav</code>.</p>
<p>Usage:</p>
<pre><code>; find all datoms for entity id == 1 (any attrs and values)
; sort by attribute, then value
(datoms db :eavt 1)
; =&gt; (#datalevin/Datom [1 :friends 2]
;     #datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [1 :name "Ivan"])

; find all datoms for entity id == 1 and attribute == :likes (any values)
; sorted by value
(datoms db :eavt 1 :likes)
; =&gt; (#datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [1 :likes "pizza"])

; find all datoms for entity id == 1, attribute == :likes and value == "pizza"
(datoms db :eavt 1 :likes "pizza")
; =&gt; (#datalevin/Datom [1 :likes "pizza"])

; find all datoms for attribute == :likes (any entity ids and values)
; sorted by entity id, then value
(datoms db :aevt :likes)
; =&gt; (#datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])

; find all datoms that have attribute == `:likes` and value == `"pizza"` (any entity id)
(datoms db :avet :likes "pizza")
; =&gt; (#datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [2 :likes "pizza"])

; find all datoms sorted by entity id, then attribute, then value
(datoms db :eavt) ; =&gt; (...)
</code></pre>
<p>Useful patterns:</p>
<pre><code>; get all values of :db.cardinality/many attribute
(-&gt;&gt; (datoms db :eavt eid attr) (map :v))

; lookup entity ids by attribute value
(-&gt;&gt; (datoms db :avet attr value) (map :e))

; find all entities with a specific attribute
(-&gt;&gt; (datoms db :aevt attr) (map :e))

; find “singleton” entity by its attr
(-&gt;&gt; (datoms db :aevt attr) first :e)

; find N entities with lowest attr value (e.g. 10 earliest posts)
(-&gt;&gt; (datoms db :avet attr) (take N))

; find N entities with highest attr value (e.g. 10 latest posts)
(-&gt;&gt; (datoms db :avet attr) (reverse) (take N))
</code></pre>
<p>Gotchas:</p>
<ul>
  <li>Index lookup is usually more efficient than doing a query with a single clause.</li>
  <li>Resulting iterator is calculated in constant time and small constant memory overhead.</li>
  <li>Iterator supports efficient <code>first</code>, <code>next</code>, <code>reverse</code>, <code>seq</code> and is itself a sequence.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L216">view source</a></div></div><div class="public anchor" id="var-db"><h3>db</h3><div class="usage"><code>(db conn)</code></div><div class="doc"><div class="markdown"><p>Returns the underlying database value from a connection.</p>
<p>Exists for Datomic API compatibility. Prefer using <code>@conn</code> directly if possible.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L586">view source</a></div></div><div class="public anchor" id="var-db-with"><h3>db-with</h3><div class="usage"><code>(db-with db tx-data)</code></div><div class="doc"><div class="markdown"><p>Applies transaction. Return the db.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L207">view source</a></div></div><div class="public anchor" id="var-db.3F"><h3>db?</h3><div class="usage"><code>(db? x)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if the given value is an database, <code>false</code> otherwise.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L165">view source</a></div></div><div class="public anchor" id="var-empty-db"><h3>empty-db</h3><div class="usage"><code>(empty-db)</code><code>(empty-db schema)</code><code>(empty-db schema dir)</code></div><div class="doc"><div class="markdown"><p>Creates an empty database with an optional schema.</p>
<p>Usage:</p>
<pre><code>(empty-db) ; =&gt; #datalevin/DB {:schema {}, :datoms []}

(empty-db {:likes {:db/cardinality :db.cardinality/many}})
; =&gt; #datalevin/DB {:schema {:likes {:db/cardinality :db.cardinality/many}}
;                    :datoms []}
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L150">view source</a></div></div><div class="public anchor" id="var-entid"><h3>entid</h3><div class="usage"><code>(entid db eid)</code></div><div class="doc"><div class="markdown"><p>Given lookup ref <code>[unique-attr value]</code>, returns numberic entity id.</p>
<p>If entity does not exist, returns <code>nil</code>.</p>
<p>For numeric <code>eid</code> returns <code>eid</code> itself (does not check for entity existence in that case).</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L73">view source</a></div></div><div class="public anchor" id="var-entity"><h3>entity</h3><div class="usage"><code>(entity db eid)</code></div><div class="doc"><div class="markdown"><p>Retrieves an entity by its id from database. Entities are lazy map-like structures to navigate Datalevin database content.</p>
<p>For <code>eid</code> pass entity id or lookup attr:</p>
<pre><code>(entity db 1)
(entity db [:unique-attr :value])
</code></pre>
<p>If entity does not exist, <code>nil</code> is returned:</p>
<pre><code>(entity db 100500) ; =&gt; nil
</code></pre>
<p>Creating an entity by id is very cheap, almost no-op, as attr access is on-demand:</p>
<pre><code>(entity db 1) ; =&gt; {:db/id 1}
</code></pre>
<p>Entity attributes can be lazily accessed through key lookups:</p>
<pre><code>(:attr (entity db 1)) ; =&gt; :value
(get (entity db 1) :attr) ; =&gt; :value
</code></pre>
<p>Cardinality many attributes are returned sequences:</p>
<pre><code>(:attrs (entity db 1)) ; =&gt; [:v1 :v2 :v3]
</code></pre>
<p>Reference attributes are returned as another entities:</p>
<pre><code>(:ref (entity db 1)) ; =&gt; {:db/id 2}
(:ns/ref (entity db 1)) ; =&gt; {:db/id 2}
</code></pre>
<p>References can be walked backwards by prepending <code>_</code> to name part of an attribute:</p>
<pre><code>(:_ref (entity db 2)) ; =&gt; [{:db/id 1}]
(:ns/_ref (entity db 2)) ; =&gt; [{:db/id 1}]
</code></pre>
<p>Reverse reference lookup returns sequence of entities unless attribute is marked as <code>:db/component</code>:</p>
<pre><code>(:_component-ref (entity db 2)) ; =&gt; {:db/id 1}
</code></pre>
<p>Entity gotchas:</p>
<ul>
  <li>Entities print as map, but are not exactly maps (they have compatible get interface though).</li>
  <li>Entities retain reference to the database.</li>
  <li>You can’t change database through entities, only read.</li>
  <li>Creating an entity by id is very cheap, almost no-op (attributes are looked up on demand).</li>
  <li>Comparing entities just compares their ids. Be careful when comparing entities taken from differenct dbs or from different versions of the same db.</li>
  <li>Accessed entity attributes are cached on entity itself (except backward references).</li>
  <li>When printing, only cached attributes (the ones you have accessed before) are printed. See <a href="datalevin.core.html#var-touch">touch</a>.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L22">view source</a></div></div><div class="public anchor" id="var-entity-db"><h3>entity-db</h3><div class="usage"><code>(entity-db entity)</code></div><div class="doc"><div class="markdown"><p>Returns a db that entity was created from.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L82">view source</a></div></div><div class="public anchor" id="var-index-range"><h3>index-range</h3><div class="usage"><code>(index-range db attr start end)</code></div><div class="doc"><div class="markdown"><p>Returns part of <code>:avet</code> index between <code>[_ attr start]</code> and <code>[_ attr end]</code> in AVET sort order.</p>
<p>Same properties as <a href="datalevin.core.html#var-datoms">datoms</a>.</p>
<p>Usage:</p>
<pre><code>(index-range db :likes "a" "zzzzzzzzz")
; =&gt; (#datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [2 :likes "pizza"])

(index-range db :likes "egg" "pineapple")
; =&gt; (#datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [2 :likes "pie"])
</code></pre>
<p>Useful patterns:</p>
<pre><code>; find all entities with age in a specific range (inclusive)
(-&gt;&gt; (index-range db :age 18 60) (map :e))
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L337">view source</a></div></div><div class="public anchor" id="var-init-db"><h3>init-db</h3><div class="usage"><code>(init-db datoms)</code><code>(init-db datoms schema)</code></div><div class="doc"><div class="markdown"><p>Low-level fn for creating database quickly from a trusted sequence of datoms.</p>
<p>Does no validation on inputs, so <code>datoms</code> must be well-formed and match schema.</p>
<p>See also <a href="datalevin.core.html#var-datom">datom</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L184">view source</a></div></div><div class="public anchor" id="var-listen.21"><h3>listen!</h3><div class="usage"><code>(listen! conn callback)</code><code>(listen! conn key callback)</code></div><div class="doc"><div class="markdown"><p>Listen for changes on the given connection. Whenever a transaction is applied to the database via <a href="datalevin.core.html#var-transact.21">transact!</a>, the callback is called with the transaction report. <code>key</code> is any opaque unique value.</p>
<p>Idempotent. Calling <a href="datalevin.core.html#var-listen.21">listen!</a> with the same key twice will override old callback with the new value.</p>
<p>Returns the key under which this listener is registered. See also <a href="datalevin.core.html#var-unlisten.21">unlisten!</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L524">view source</a></div></div><div class="public anchor" id="var-pull"><h3>pull</h3><div class="usage"><code>(pull db selector eid)</code></div><div class="doc"><div class="markdown"><p>Fetches data from database using recursive declarative description. See <a href="https://docs.datomic.com/on-prem/pull.html">docs.datomic.com/on-prem/pull.html</a>.</p>
<p>Unlike <a href="datalevin.core.html#var-entity">entity</a>, returns plain Clojure map (not lazy).</p>
<p>Usage:</p>
<pre><code>(pull db [:db/id, :name, :likes, {:friends [:db/id :name]}] 1)
; =&gt; {:db/id   1,
;     :name    "Ivan"
;     :likes   [:pizza]
;     :friends [{:db/id 2, :name "Oleg"}]}
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L103">view source</a></div></div><div class="public anchor" id="var-pull-many"><h3>pull-many</h3><div class="usage"><code>(pull-many db selector eids)</code></div><div class="doc"><div class="markdown"><p>Same as <a href="datalevin.core.html#var-pull">pull</a>, but accepts sequence of ids and returns sequence of maps.</p>
<p>Usage:</p>
<pre><code>(pull-many db [:db/id :name] [1 2])
; =&gt; [{:db/id 1, :name "Ivan"}
;     {:db/id 2, :name "Oleg"}]
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L118">view source</a></div></div><div class="public anchor" id="var-q"><h3>q</h3><div class="usage"><code>(q query &amp; inputs)</code></div><div class="doc"><div class="markdown"><p>Executes a datalog query. See <a href="https://docs.datomic.com/on-prem/query.html">docs.datomic.com/on-prem/query.html</a>.</p>
<p>Usage:</p>
<pre><code>(q '[:find ?value
     :where [_ :likes ?value]]
   db)
; =&gt; #{["fries"] ["candy"] ["pie"] ["pizza"]}
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L133">view source</a></div></div><div class="public anchor" id="var-reset-conn.21"><h3>reset-conn!</h3><div class="usage"><code>(reset-conn! conn db)</code><code>(reset-conn! conn db tx-meta)</code></div><div class="doc"><div class="markdown"><p>Forces underlying <code>conn</code> value to become <code>db</code>. Will generate a tx-report that will remove everything from old value and insert everything from the new one.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L502">view source</a></div></div><div class="public anchor" id="var-resolve-tempid"><h3>resolve-tempid</h3><div class="usage"><code>(resolve-tempid _db tempids tempid)</code></div><div class="doc"><div class="markdown"><p>Does a lookup in tempids map, returning an entity id that tempid was resolved to.</p>
<p>Exists for Datomic API compatibility. Prefer using map lookup directly if possible.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L578">view source</a></div></div><div class="public anchor" id="var-rseek-datoms"><h3>rseek-datoms</h3><div class="usage"><code>(rseek-datoms db index)</code><code>(rseek-datoms db index c1)</code><code>(rseek-datoms db index c1 c2)</code><code>(rseek-datoms db index c1 c2 c3)</code><code>(rseek-datoms db index c1 c2 c3 c4)</code></div><div class="doc"><div class="markdown"><p>Same as <a href="datalevin.core.html#var-seek-datoms">seek-datoms</a>, but goes backwards until the beginning of the index.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L328">view source</a></div></div><div class="public anchor" id="var-seek-datoms"><h3>seek-datoms</h3><div class="usage"><code>(seek-datoms db index)</code><code>(seek-datoms db index c1)</code><code>(seek-datoms db index c1 c2)</code><code>(seek-datoms db index c1 c2 c3)</code><code>(seek-datoms db index c1 c2 c3 c4)</code></div><div class="doc"><div class="markdown"><p>Similar to <a href="datalevin.core.html#var-datoms">datoms</a>, but will return datoms starting from specified components and including rest of the database until the end of the index.</p>
<p>If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.</p>
<p>Usage:</p>
<pre><code>(seek-datoms db :eavt 1)
; =&gt; (#datalevin/Datom [1 :friends 2]
;     #datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [1 :name "Ivan"]
;     #datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])

(seek-datoms db :eavt 1 :name)
; =&gt; (#datalevin/Datom [1 :name "Ivan"]
;     #datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])

(seek-datoms db :eavt 2)
; =&gt; (#datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])

; no datom [2 :likes "fish"], so starts with one immediately following such in index
(seek-datoms db :eavt 2 :likes "fish")
; =&gt; (#datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L290">view source</a></div></div><div class="public anchor" id="var-squuid"><h3>squuid</h3><div class="usage"><code>(squuid)</code><code>(squuid msec)</code></div><div class="doc"><div class="markdown"><p>Generates a UUID that grow with time. Such UUIDs will always go to the end of the index and that will minimize insertions in the middle.</p>
<p>Consist of 64 bits of current UNIX timestamp (in seconds) and 64 random bits (2^64 different unique values per second).</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L665">view source</a></div></div><div class="public anchor" id="var-squuid-time-millis"><h3>squuid-time-millis</h3><div class="usage"><code>(squuid-time-millis uuid)</code></div><div class="doc"><div class="markdown"><p>Returns time that was used in <a href="datalevin.core.html#var-squuid">squuid</a> call, in milliseconds, rounded to the closest second.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L693">view source</a></div></div><div class="public anchor" id="var-tempid"><h3>tempid</h3><div class="usage"><code>(tempid part)</code><code>(tempid part x)</code></div><div class="doc"><div class="markdown"><p>Allocates and returns an unique temporary id (a negative integer). Ignores <code>part</code>. Returns <code>x</code> if it is specified.</p>
<p>Exists for Datomic API compatibility. Prefer using negative integers directly if possible.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L564">view source</a></div></div><div class="public anchor" id="var-touch"><h3>touch</h3><div class="usage"><code>(touch e)</code></div><div class="doc"><div class="markdown"><p>Forces all entity attributes to be eagerly fetched and cached. Only usable for debug output.</p>
<p>Usage:</p>
<pre><code>(entity db 1) ; =&gt; {:db/id 1}
(touch (entity db 1)) ; =&gt; {:db/id 1, :dislikes [:pie], :likes [:pizza]}
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L89">view source</a></div></div><div class="public anchor" id="var-transact"><h3>transact</h3><div class="usage"><code>(transact conn tx-data)</code><code>(transact conn tx-data tx-meta)</code></div><div class="doc"><div class="markdown"><p>Same as <a href="datalevin.core.html#var-transact.21">transact!</a>, but returns an immediately realized future.</p>
<p>Exists for Datomic API compatibility. Prefer using <a href="datalevin.core.html#var-transact.21">transact!</a> if possible.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L602">view source</a></div></div><div class="public anchor" id="var-transact.21"><h3>transact!</h3><div class="usage"><code>(transact! conn tx-data)</code><code>(transact! conn tx-data tx-meta)</code></div><div class="doc"><div class="markdown"><p>Applies transaction the underlying database value and atomically updates connection reference to point to the result of that transaction, new db value.</p>
<p>Returns transaction report, a map:</p>
<pre><code> { :db-before ...       ; db value before transaction
   :db-after  ...       ; db value after transaction
   :tx-data   [...]     ; plain datoms that were added/retracted from db-before
   :tempids   {...}     ; map of tempid from tx-data =&gt; assigned entid in db-after
   :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`
</code></pre>
<p>Note! <code>conn</code> will be updated in-place and is not returned from <a href="datalevin.core.html#var-transact.21">transact!</a>.</p>
<p>Usage:</p>
<pre><code>; add a single datom to an existing entity (1)
(transact! conn [[:db/add 1 :name "Ivan"]])

; retract a single datom
(transact! conn [[:db/retract 1 :name "Ivan"]])

; retract single entity attribute
(transact! conn [[:db.fn/retractAttribute 1 :name]])

; ... or equivalently (since Datomic changed its API to support this):
(transact! conn [[:db/retract 1 :name]])

; retract all entity attributes (effectively deletes entity)
(transact! conn [[:db.fn/retractEntity 1]])

; create a new entity (`-1`, as any other negative value, is a tempid
; that will be replaced with Datalevin to a next unused eid)
(transact! conn [[:db/add -1 :name "Ivan"]])

; check assigned id (here `*1` is a result returned from previous `transact!` call)
(def report *1)
(:tempids report) ; =&gt; {-1 296}

; check actual datoms inserted
(:tx-data report) ; =&gt; [#datalevin/Datom [296 :name "Ivan"]]

; tempid can also be a string
(transact! conn [[:db/add "ivan" :name "Ivan"]])
(:tempids *1) ; =&gt; {"ivan" 297}

; reference another entity (must exist)
(transact! conn [[:db/add -1 :friend 296]])

; create an entity and set multiple attributes (in a single transaction
; equal tempids will be replaced with the same unused yet entid)
(transact! conn [[:db/add -1 :name "Ivan"]
                 [:db/add -1 :likes "fries"]
                 [:db/add -1 :likes "pizza"]
                 [:db/add -1 :friend 296]])

; create an entity and set multiple attributes (alternative map form)
(transact! conn [{:db/id  -1
                  :name   "Ivan"
                  :likes  ["fries" "pizza"]
                  :friend 296}])

; update an entity (alternative map form). Can’t retract attributes in
; map form. For cardinality many attrs, value (fish in this example)
; will be added to the list of existing values
(transact! conn [{:db/id  296
                  :name   "Oleg"
                  :likes  ["fish"]}])

; ref attributes can be specified as nested map, that will create netsed entity as well
(transact! conn [{:db/id  -1
                  :name   "Oleg"
                  :friend {:db/id -2
                           :name "Sergey"}])

; reverse attribute name can be used if you want created entity to become
; a value in another entity reference
(transact! conn [{:db/id  -1
                  :name   "Oleg"
                  :_friend 296}])
; equivalent to
(transact! conn [{:db/id  -1, :name   "Oleg"}
                 {:db/id 296, :friend -1}])
; equivalent to
(transact! conn [[:db/add  -1 :name   "Oleg"]
                 {:db/add 296 :friend -1]])
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L408">view source</a></div></div><div class="public anchor" id="var-transact-async"><h3>transact-async</h3><div class="usage"><code>(transact-async conn tx-data)</code><code>(transact-async conn tx-data tx-meta)</code></div><div class="doc"><div class="markdown"><p>Calls <a href="datalevin.core.html#var-transact.21">transact!</a> on a future thread pool, returning immediately.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L643">view source</a></div></div><div class="public anchor" id="var-unlisten.21"><h3>unlisten!</h3><div class="usage"><code>(unlisten! conn key)</code></div><div class="doc"><div class="markdown"><p>Removes registered listener from connection. See also <a href="datalevin.core.html#var-listen.21">listen!</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L538">view source</a></div></div><div class="public anchor" id="var-with"><h3>with</h3><div class="usage"><code>(with db tx-data)</code><code>(with db tx-data tx-meta)</code></div><div class="doc"><div class="markdown"><p>Same as <a href="datalevin.core.html#var-transact.21">transact!</a>. Returns transaction report (see <a href="datalevin.core.html#var-transact.21">transact!</a>).</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L194">view source</a></div></div></div></body></html>